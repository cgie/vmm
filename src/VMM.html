<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Vector-matrix multiplications</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Vector-matrix multiplications</h1>
</div>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# Language Rank2Types #-}</span></code></pre>
<p>This document contains a slightly elaborated version of the code presented in <em>Graph Problems and Vector-Matrix Multiplications in Haskell</em>.</p>
<p>This module uses the separated modules</p>
<ul>
<li><a href="./Semiring.html"><code>Semiring</code></a> that contains the semiring type class and some exemplary instances and</li>
<li><a href="./RandomMatrix.html"><code>RandomMatrix</code></a> that allows the creation of matrices that are generated randomly.</li>
</ul>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">VMM</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>              ( <span class="dt">Applicative</span> ( .. ) )
<span class="kw">import </span><span class="dt">Control.Arrow</span>                    ( second, (&amp;&amp;&amp;) )
<span class="kw">import </span><span class="dt">Control.Monad</span>                    ( ap, liftM, <span class="dt">MonadPlus</span> ( .. ) )
<span class="kw">import </span><span class="dt">Control.Monad.ST.Lazy.Safe</span>       ( <span class="dt">ST</span>, runST )
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Class</span>        ( lift )
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Maybe</span>        ( <span class="dt">MaybeT</span> ( .. ) )
<span class="kw">import </span><span class="dt">Data.Array.ST</span>                    ( <span class="dt">STArray</span>, writeArray, readArray, newArray )
<span class="kw">import </span><span class="dt">Data.Char</span>                        ( chr )
<span class="kw">import </span><span class="dt">Data.List</span>                        ( group, sort, intercalate )
<span class="kw">import </span><span class="dt">Data.Maybe</span>                       ( catMaybes )
<span class="kw">import </span><span class="dt">Data.Sequence</span>                    ( <span class="dt">Seq</span>, (|&gt;), empty )
<span class="kw">import </span><span class="dt">Data.Tree</span>                        ( <span class="dt">Tree</span> ( <span class="dt">Node</span> ), <span class="dt">Forest</span> )</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Semiring</span>
<span class="kw">import </span><span class="dt">RandomMatrix</span></code></pre>
<h1 id="preliminaries">Preliminaries</h1>
<p>The basic data types for the described framework.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Vertex</span>   <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Arc</span> a    <span class="fu">=</span> (<span class="dt">Int</span>, a)
<span class="kw">newtype</span> <span class="dt">Vec</span> a <span class="fu">=</span> <span class="dt">Vec</span> {<span class="ot"> unVec ::</span> [<span class="dt">Arc</span> a] }</code></pre>
<p>A pretty-printing <code>Show</code>-instance for vectors.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> a) <span class="kw">where</span>

 show (<span class="dt">Vec</span> ixs) <span class="fu">=</span> foldr showElem <span class="st">&quot;&quot;</span> ixs
   <span class="kw">where</span> showElem (i, x) ixs <span class="fu">=</span> unwords [<span class="st">&quot;(&quot;</span>, show i, <span class="st">&quot;|&quot;</span>, show x, <span class="st">&quot;)&quot;</span>, ixs]</code></pre>
<p>The <code>Functor</code> instance maps the given function over every value (i.e. second component) in the association list.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Vec</span> <span class="kw">where</span>

 fmap f <span class="fu">=</span> <span class="dt">Vec</span> <span class="fu">.</span> map (second f) <span class="fu">.</span> unVec</code></pre>
<p>For example we have the following result:</p>
<ul>
<li><code class="sourceCode haskell">fmap chr (<span class="dt">Vec</span> [(<span class="dv">2</span>, <span class="dv">109</span>), (<span class="dv">3</span>, <span class="dv">97</span>), (<span class="dv">5</span>, <span class="dv">112</span>)]) <span class="fu">==</span> <span class="dt">Vec</span> [(<span class="dv">2</span>, <span class="ch">&#39;m&#39;</span>), (<span class="dv">3</span>, <span class="ch">&#39;a&#39;</span>), (<span class="dv">5</span>, <span class="ch">&#39;p&#39;</span>)]</code></li>
</ul>
<p>We use the constant <code class="sourceCode haskell">emptyVec</code> for abbreviation.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">emptyVec ::</span> <span class="dt">Vec</span> a
emptyVec <span class="fu">=</span> <span class="dt">Vec</span> []</code></pre>
<p>This function checks whether the wrapped association list of a vector is empty.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isEmptyVec ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEmptyVec <span class="fu">=</span> null <span class="fu">.</span> unVec</code></pre>
<p>For simplicity of implementation and testing we define conversion functions between sets of vertices and vectors. To obtain a vector from a vertex set we need to sort the set and remove all duplicates. Then every vertex needs to be given a value, which is simple to implement with an additional function.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">toVecFrom ::</span> (<span class="dt">Vertex</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
toVecFrom f <span class="fu">=</span> <span class="dt">Vec</span> <span class="fu">.</span> map ((id <span class="fu">&amp;&amp;&amp;</span> f) <span class="fu">.</span> head) <span class="fu">.</span> group <span class="fu">.</span> sort</code></pre>
<p>Using the same value for every vertex is the simplest case.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">toVecWith ::</span> a <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
toVecWith <span class="fu">=</span> toVecFrom <span class="fu">.</span> const</code></pre>
<p>Using <code class="sourceCode haskell">()</code> as a specific value is realised as follows.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">toVec ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Vec</span> ()
toVec <span class="fu">=</span> toVecWith ()</code></pre>
<p>Finally, using a <code>one</code> of some semiring is useful in an algebraic context.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">toVec1 ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Vec</span> s
toVec1 <span class="fu">=</span> toVecWith one</code></pre>
<p>Transforming back from a vector is simple, since only the values need to be removed.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fromVec ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
fromVec <span class="fu">=</span> map fst <span class="fu">.</span> unVec</code></pre>
<h2 id="set-operations-on-vectors">Set operations on vectors</h2>
<p>Set operations on vectors can be easily defined using a merging technique similar to the one in <code>Data.IntMap</code>. To avoid boilerplate code we parametrise merging as follows:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">mergeWith ::</span> ([<span class="dt">Arc</span> b] <span class="ot">-&gt;</span> [c])               <span class="co">-- ^ left list is empty</span>
          <span class="ot">-&gt;</span> ([<span class="dt">Arc</span> a] <span class="ot">-&gt;</span> [c])               <span class="co">-- ^ right list is empty</span>
          <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [c] <span class="ot">-&gt;</span> [c])  <span class="co">-- ^ equality case</span>
          <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [c] <span class="ot">-&gt;</span> [c])  <span class="co">-- ^ left index is smaller than the right one</span>
          <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [c] <span class="ot">-&gt;</span> [c])  <span class="co">-- ^ left index is larger than the right one</span>
          <span class="ot">-&gt;</span> [<span class="dt">Arc</span> a] <span class="ot">-&gt;</span> [<span class="dt">Arc</span> b] <span class="ot">-&gt;</span> [c]
mergeWith leftEmpty rightEmpty eq lt gt <span class="fu">=</span> go <span class="kw">where</span>

    go []                 jys                             <span class="fu">=</span> leftEmpty jys
    go ixs                []                              <span class="fu">=</span> rightEmpty ixs
    go l1<span class="fu">@</span>( (i, x) <span class="fu">:</span> ixs) l2<span class="fu">@</span>( (j, y) <span class="fu">:</span> jys ) <span class="fu">|</span> i <span class="fu">==</span> j    <span class="fu">=</span> eq i x y (go ixs jys)
                                              <span class="fu">|</span> i <span class="fu">&lt;</span>  j    <span class="fu">=</span> lt i x y (go ixs l2)
                                              <span class="fu">|</span> otherwise <span class="fu">=</span> gt j x y (go l1 jys)</code></pre>
<p>This function ignores the first three parameters and returns the fourth.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">constFourth ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d
constFourth _ _ _ <span class="fu">=</span> id</code></pre>
<p>This function computes the union of two vectors applying the supplied function in case of index equality.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">unionWith ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
unionWith f (<span class="dt">Vec</span> xs) (<span class="dt">Vec</span> ys) <span class="fu">=</span> <span class="dt">Vec</span> (go xs ys) <span class="kw">where</span>

  go <span class="fu">=</span> mergeWith id id (\i x y r <span class="ot">-&gt;</span> (i, f x y) <span class="fu">:</span> r) (\i x _ r <span class="ot">-&gt;</span> (i, x) <span class="fu">:</span> r) (\i _ y r <span class="ot">-&gt;</span> (i, y) <span class="fu">:</span> r)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bigUnionWith ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [<span class="dt">Vec</span> a] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
bigUnionWith op <span class="fu">=</span> foldr (unionWith op) emptyVec</code></pre>
<p>One simple instance of these union functions are the &quot;left-biased union&quot; and its repeated application. The left-biased union takes the value at the leftmost occurrence of an index.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">(\\<span class="fu">/</span>)<span class="ot"> ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
(\\<span class="fu">/</span>) <span class="fu">=</span> unionWith const</code></pre>
<p>The repeated application is then the leftmost union that is just as simple to define.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">leftmostUnion ::</span> [<span class="dt">Vec</span> a] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
leftmostUnion <span class="fu">=</span> bigUnionWith const</code></pre>
<p>The intersection function for intersecting association lists using a user supplied combination function. It is very similar to <code class="sourceCode haskell">zipWith</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">intersectionWithKey ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> b <span class="ot">-&gt;</span> [c]
intersectionWithKey f (<span class="dt">Vec</span> xs) (<span class="dt">Vec</span> ys) <span class="fu">=</span> go xs ys <span class="kw">where</span>
  go <span class="fu">=</span> mergeWith (const []) (const []) (\i x y r <span class="ot">-&gt;</span> f i x y <span class="fu">:</span> r) constFourth constFourth</code></pre>
<p>One useful intersection instance is the &quot;left-biased intersection&quot; that takes the left value in case the index is present in both vectors.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">(<span class="fu">//</span>\)<span class="ot"> ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> b <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
v <span class="fu">//</span>\ w <span class="fu">=</span> <span class="dt">Vec</span> (intersectionWithKey (\i x _ <span class="ot">-&gt;</span> (i, x)) v w)</code></pre>
<p>This function denotes set difference. Its &quot;skew&quot; type is due to the fact that all values in its second argument are ignored, because only the indices are being compared.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">(\\)<span class="ot"> ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> b <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
<span class="dt">Vec</span> xs \\ <span class="dt">Vec</span> ys <span class="fu">=</span> <span class="dt">Vec</span> (go xs ys) <span class="kw">where</span>
  go <span class="fu">=</span> mergeWith (const []) id constFourth (\i x _ r <span class="ot">-&gt;</span> (i, x) <span class="fu">:</span> r) constFourth</code></pre>
<h2 id="matrices-and-the-multiplication-generators">Matrices and the multiplication generators</h2>
<p>Matrices are wrapped in an additional newtype (contrary to the definition in the paper) to allow a pretty-printing <code class="sourceCode haskell"><span class="dt">Show</span></code> instance.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Mat</span> a  <span class="fu">=</span> <span class="dt">Mat</span> {<span class="ot"> matrix ::</span> <span class="dt">Vec</span> (<span class="dt">Vec</span> a) }

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Mat</span> a) <span class="kw">where</span>

  show <span class="fu">=</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">.</span> map (uncurry f) <span class="fu">.</span> unVec <span class="fu">.</span> matrix <span class="kw">where</span>
    f j r <span class="fu">=</span> unwords [show j, <span class="st">&quot;:&quot;</span>, show r]</code></pre>
<p>Matrices also have a natural <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance that uses the corresponding vector instance twice.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Mat</span> <span class="kw">where</span>

    fmap f <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> matrix</code></pre>
<p>Given a fixed value <code class="sourceCode haskell">x</code> this function provides a vector of vertices in the matrix where the value at every index is <code class="sourceCode haskell">x</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">verticesWith ::</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> b <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
verticesWith x <span class="fu">=</span> fmap (const x) <span class="fu">.</span> matrix</code></pre>
<p>The scalar multiplication function. In the call <code class="sourceCode haskell">sMultWith times i x vec</code> the supplied &quot;multiplication&quot; <code class="sourceCode haskell">times</code> is applied to the &quot;uncurried scalar&quot; <code class="sourceCode haskell">(i, x)</code> and then mapped over every value in the vector <code class="sourceCode haskell">vec</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sMultWith ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> u)<span class="ot">-&gt;</span>  <span class="dt">Int</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Vec</span> t <span class="ot">-&gt;</span> <span class="dt">Vec</span> u
sMultWith mult i x <span class="fu">=</span> fmap (mult i x)</code></pre>
<p>The actual vector matrix multiplication. It takes a generalised sum (first argument), a generalised scalar multiplication (second argument), a vector and a matrix and applies the sum function to the result of the intersection of the vector with the matrix, which in turn is obtained using the scalar multiplication function.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">vecMatMult ::</span> ([u] <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Vec</span> t <span class="ot">-&gt;</span> u) <span class="ot">-&gt;</span> <span class="dt">Vec</span> s <span class="ot">-&gt;</span> <span class="dt">Mat</span> t <span class="ot">-&gt;</span> v
vecMatMult bigsum sMult v m <span class="fu">=</span> bigsum (intersectionWithKey sMult v (matrix m))</code></pre>
<h1 id="applications-of-the-multiplication-scheme">Applications of the Multiplication Scheme</h1>
<h2 id="algebraic-multiplication">Algebraic multiplication</h2>
<p>This function is the usual multiplication of a vector with a matrix in the context of semirings.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Vec</span> s <span class="ot">-&gt;</span> <span class="dt">Mat</span> s <span class="ot">-&gt;</span> <span class="dt">Vec</span> s
(<span class="fu">.*</span>) <span class="fu">=</span> vecMatMult (bigUnionWith (<span class="fu">.+.</span>)) (sMultWith (\ _ x y <span class="ot">-&gt;</span> x <span class="fu">.*.</span> y))</code></pre>
<p>Assuming an additional <code class="sourceCode haskell"><span class="dt">Eq</span></code> constraint we can define the predicates</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isZero ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Eq</span> s) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isZero <span class="fu">=</span> (zero <span class="fu">==</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isOne ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Eq</span> s) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isOne <span class="fu">=</span> (one <span class="fu">==</span>)</code></pre>
<p>that check whether a semiring element is <code class="sourceCode haskell">zero</code> or <code class="sourceCode haskell">one</code>. Alternatively, one can require these predicates to be part of the semiring type class.</p>
<p>This function removes all pairs from a vector whose value is <code class="sourceCode haskell">zero</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">nonZero ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Eq</span> s) <span class="ot">=&gt;</span> <span class="dt">Vec</span> s <span class="ot">-&gt;</span> <span class="dt">Vec</span> s
nonZero <span class="fu">=</span> <span class="dt">Vec</span> <span class="fu">.</span> filter (not <span class="fu">.</span> isZero <span class="fu">.</span> snd) <span class="fu">.</span> unVec</code></pre>
<p>This is a variant of <code class="sourceCode haskell">(<span class="fu">.*</span>)</code> that uses algebraic laws to avoid zeroes in the result vector as well as avoiding possibly unnecessary computations.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.**) ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Eq</span> s) <span class="ot">=&gt;</span> <span class="dt">Vec</span> s <span class="ot">-&gt;</span> <span class="dt">Mat</span> s <span class="ot">-&gt;</span> <span class="dt">Vec</span> s
(<span class="fu">.**</span>) <span class="fu">=</span> vecMatMult (nonZero <span class="fu">.</span> bigUnionWith (<span class="fu">.+.</span>)) sMult <span class="kw">where</span>
  sMult i s vec <span class="fu">|</span> isZero s  <span class="fu">=</span> emptyVec
                <span class="fu">|</span> isOne  s  <span class="fu">=</span> vec
                <span class="fu">|</span> otherwise <span class="fu">=</span> nonZero (sMultWith (\ _ x y <span class="ot">-&gt;</span> x<span class="fu">.*.</span>y) i s vec)</code></pre>
<h2 id="successors-computation-in-different-flavours.">Successors computation in different flavours.</h2>
<p>This function computes the successors of a set of vertices in a given graph, where the graph is represented by its adjacency matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.-&gt;) ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
v <span class="fu">.-&gt;</span> m <span class="fu">=</span> fromVec (toVec v <span class="fu">.*&gt;</span> m)</code></pre>
<p>The actual multiplication is pseudo-Boolean: every performed multiplication is essentially a multiplication by <code class="sourceCode haskell">one</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*&gt;) ::</span> <span class="dt">Vec</span> s <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
(<span class="fu">.*&gt;</span>) <span class="fu">=</span> vecMatMult leftmostUnion (\ _ _ row <span class="ot">-&gt;</span> row)</code></pre>
<p>This is an algebraic version of the successor multiplication. The underlying semiring needs to be idempotent, i.e. <code class="sourceCode haskell">x <span class="fu">.+.</span> x <span class="fu">==</span> x</code> for all <code class="sourceCode haskell"><span class="ot">x ::</span> s</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.-&gt;*) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Mat</span> s <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
(<span class="fu">.-&gt;*</span>) v m <span class="fu">=</span> fromVec (toVec1 v <span class="fu">.*</span> m)</code></pre>
<p>The above function <code class="sourceCode haskell">(<span class="fu">.-&gt;*</span>)</code> can be instantiated with a particular idempotent semiring, e.g. the Boolean semiring.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.-&gt;&gt;) ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
(<span class="fu">.-&gt;&gt;</span>) v m <span class="fu">=</span> v <span class="fu">.-&gt;*</span> fmap (const (<span class="ot">one ::</span> <span class="dt">Bool</span>)) m</code></pre>
<h2 id="successors-that-know-the-number-of-their-predecessors">Successors that know the number of their predecessors</h2>
<p>This function computes the successors of a vertex set and counts the number of times each successor is encountered as well.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.#) ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Number</span> <span class="dt">Int</span>)
v <span class="fu">.#</span> m <span class="fu">=</span> toVecWith <span class="dv">0</span> v <span class="fu">.*#</span> m</code></pre>
<p>The underlying multiplication of this function is the following one. It maps every value that is encountered in the adjacency list of a vertex to <code class="sourceCode haskell"><span class="dv">1</span></code> and then uses numerical addition to add the resulting ones.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*#) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Vec</span> (<span class="dt">Number</span> a) <span class="ot">-&gt;</span> <span class="dt">Mat</span> b <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Number</span> a)
(<span class="fu">.*#</span>) <span class="fu">=</span> vecMatMult (bigUnionWith (<span class="fu">+</span>)) (sMultWith (\_ _ _ <span class="ot">-&gt;</span> <span class="dv">1</span>))</code></pre>
<h2 id="existence-of-successors">Existence of successors</h2>
<p>This is a very simple instance of a scalar multiplication -- it ignores the vertex and the value and merely checks whether the supplied vector is non-empty.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">hasSuccsMul ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasSuccsMul _ _  <span class="fu">=</span> not <span class="fu">.</span> isEmptyVec</code></pre>
<p>The following instance of a vector-matrix multiplications checks whether the successor set of a given vector is non-empty.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.?) ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
(<span class="fu">.?</span>) <span class="fu">=</span> vecMatMult or hasSuccsMul</code></pre>
<h2 id="prolonging-a-single-path">Prolonging a single path</h2>
<p>Vertex paths are represented by a <code class="sourceCode haskell"><span class="dt">Seq</span></code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Path</span> <span class="fu">=</span> <span class="dt">Seq</span> <span class="dt">Vertex</span></code></pre>
<p>Given the adjacency matrix of a graph and a vector where each vertex is labelled with a single path that leads to this vertex this multiplication computes the successors of this vector and marks every successor with a single path that leads to it as well.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*~) ::</span> <span class="dt">Vec</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> <span class="dt">Path</span>
(<span class="fu">.*~</span>) <span class="fu">=</span> vecMatMult leftmostUnion pathMul</code></pre>
<p>The scalar multiplication is applied to a vertex and its adjacency list only, so any given path can be prolonged by simply additing the current vertex to the end of this path.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">pathMul ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> <span class="dt">Path</span>
pathMul <span class="fu">=</span> sMultWith (\v path _ <span class="ot">-&gt;</span> path <span class="fu">|&gt;</span> v)</code></pre>
<h2 id="prolonging-all-paths">Prolonging all paths</h2>
<p>This multiplication prolongs all paths that lead to a target vertex by exactly one step through the graph represented by the given matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*~~) ::</span> <span class="dt">Vec</span> [<span class="dt">Path</span>] <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> [<span class="dt">Path</span>]
(<span class="fu">.*~~</span>) <span class="fu">=</span> vecMatMult allUnion pathsMul</code></pre>
<p>The <code class="sourceCode haskell">allUnion</code> function collects all results in their order of occurrence.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">allUnion ::</span> [<span class="dt">Vec</span> [a]] <span class="ot">-&gt;</span> <span class="dt">Vec</span> [a]
allUnion <span class="fu">=</span> bigUnionWith (<span class="fu">++</span>)</code></pre>
<p>Similarly to the <code class="sourceCode haskell">pathMul</code> function, the following function prolongs all paths instead of just one.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">pathsMul ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> [<span class="dt">Path</span>] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> [<span class="dt">Path</span>]
pathsMul <span class="fu">=</span> sMultWith (\ v ps _ <span class="ot">-&gt;</span> map (<span class="fu">|&gt;</span> v) ps)</code></pre>
<h2 id="outgoing-values">Outgoing values</h2>
<p>The following multiplication computes the successors of a vertex and adds all predecessors and their corresponding values to the <code class="sourceCode haskell"><span class="dt">Arc</span></code>-list at the respective index.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*||) ::</span> <span class="dt">Vec</span> [<span class="dt">Arc</span> a] <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> [<span class="dt">Arc</span> a]
(<span class="fu">.*||</span>) <span class="fu">=</span> vecMatMult allUnion outMult</code></pre>
<p>The essence of the above multiplication is this scalar multiplication, which prepends the &quot;current&quot; vertex and the outgoing value to the given list of vertex-value pairs.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">outMult ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> [<span class="dt">Arc</span> a] <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> [<span class="dt">Arc</span> a]
outMult <span class="fu">=</span> sMultWith (\i ovs a <span class="ot">-&gt;</span> (i, a) <span class="fu">:</span> ovs)</code></pre>
<p>An unusual application of the above multiplication is the transposition of a homogeneous matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">transpose ::</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
transpose mat <span class="fu">=</span> <span class="dt">Mat</span> (fmap <span class="dt">Vec</span> ((vertices <span class="fu">.*||</span> mat) \\<span class="fu">/</span> vertices)) <span class="kw">where</span>
    vertices <span class="fu">=</span> verticesWith [] mat</code></pre>
<p>It is possible to define a very similar function that computes the transposition of a heterogeneous matrix by adding an additional <code class="sourceCode haskell"><span class="dt">Int</span></code> argument that denotes the number of columns. This number can then be used in the &quot;correction&quot; step (application of <code class="sourceCode haskell">(\\<span class="fu">/</span>)</code>) to add the correct number of columns.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">transposeHeterogeneous ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
transposeHeterogeneous cols mat <span class="fu">=</span> <span class="dt">Mat</span> (fmap <span class="dt">Vec</span> ((vertices <span class="fu">.*||</span> mat) \\<span class="fu">/</span> vertices&#39;)) <span class="kw">where</span>
    vertices  <span class="fu">=</span> verticesWith [] mat
    vertices&#39; <span class="fu">=</span> toVecWith [] [<span class="dv">0</span> <span class="fu">..</span> cols <span class="fu">-</span> <span class="dv">1</span>]</code></pre>
<h2 id="collecting-the-reachability-forest">Collecting the reachability forest</h2>
<p>Assuming that a vector is labelled with a reachability forest (from another vector) at every index this multiplication computes the reachability forest that is obtained by walking a single step through the graph.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(.*++) ::</span> <span class="dt">Vec</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>) <span class="ot">-&gt;</span> <span class="dt">Mat</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>)
(<span class="fu">.*++</span>) <span class="fu">=</span> vecMatMult allUnion fMult</code></pre>
<p>The scalar multiplication labels every successor of a given vertex with a forest starting in that vertex that leads to the successor. The concatenation of all these forests is then the result and is computed above by using <code class="sourceCode haskell">allUnion</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fMult ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>)
fMult <span class="fu">=</span> sMultWith (\v forest _ <span class="ot">-&gt;</span> [<span class="dt">Node</span> v forest])</code></pre>
<p>An application of the above multiplication is the computation of the reachability forest along shortest paths between two vertex sets, which is provided by the following function.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">reachForest ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> b <span class="ot">-&gt;</span> [<span class="dt">Mat</span> c] <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>)
reachForest a <span class="fu">=</span> shortestWith (<span class="fu">.*++</span>) (fmap (const []) a)</code></pre>
<h1 id="reachability-and-iterated-computations">Reachability and Iterated Computations</h1>
<p>Repeated application of (fitting) multiplication can be used to compute reachability layers along shortest paths. The following function computes the reachability layers in a breadth-first search (BFS) fashion, disregarding the BFS order.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">reachWith ::</span> (<span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> b <span class="ot">-&gt;</span> <span class="dt">Vec</span> a) <span class="co">-- multiplication that collects information</span>
          <span class="ot">-&gt;</span> <span class="dt">Vec</span> a                     <span class="co">-- start vector</span>
          <span class="ot">-&gt;</span> [<span class="dt">Mat</span> b]                   <span class="co">-- list of graphs traversed in every step</span>
          <span class="ot">-&gt;</span> [<span class="dt">Vec</span> a]
reachWith _   r [] <span class="fu">=</span> [r]
reachWith mul r gs <span class="fu">=</span> go r (verticesWith () (head gs)) <span class="kw">where</span>

    go v w <span class="fu">|</span> isEmptyVec v <span class="fu">=</span> []
           <span class="fu">|</span> otherwise    <span class="fu">=</span> v <span class="fu">:</span> go v&#39; w&#39; <span class="kw">where</span>
                    w&#39; <span class="fu">=</span> w \\ v
                    v&#39; <span class="fu">=</span> foldl mul v gs <span class="fu">//</span>\ w&#39;</code></pre>
<p>The reachability strategy can be used to compute the vector that consists of the vertices that can be reached along shortest paths between two vertex sets. Each of these vertices is labelled with the information collected by the supplied multiplication.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">shortestWith ::</span> (<span class="dt">Vec</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> c <span class="ot">-&gt;</span> <span class="dt">Vec</span> a) <span class="co">-- multiplication that collects information</span>
             <span class="ot">-&gt;</span> <span class="dt">Vec</span> a                     <span class="co">-- start vector</span>
             <span class="ot">-&gt;</span> <span class="dt">Vec</span> b                     <span class="co">-- target vector</span>
             <span class="ot">-&gt;</span> [<span class="dt">Mat</span> c]                   <span class="co">-- list of graphs traversed in every step</span>
             <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
shortestWith mul a b gs <span class="fu">=</span> head (dropWhile isEmptyVec (map (<span class="fu">//</span>\ b) (reachWith mul a gs)) <span class="fu">++</span> [<span class="dt">Vec</span> []])</code></pre>
<h1 id="maximal-set-of-pairwise-disjoint-shortest-paths">Maximal Set of Pairwise Disjoint Shortest Paths</h1>
<p>The computation of a maximal set of pairwise disjoint shortest paths between two vertex sets is realised by computing the reachability forest with the <code class="sourceCode haskell">reachForest</code> function and then pruning it with the following strategy. If there is no tree left, there no path left in the forest. If on the other hand there is a leftmost tree, check whether its root node is visited. If it is, continue with the remainder of the forest. If it's not, then visit this vertex. Next compute a path candidate. In case the candidate is indeed a path, add the vertex to its end and obtain a path in the graph. Otherwise continue searching in the remaining forest. The candidate is the empty path in case the current subforest is empty, since this means that the bottom of the forest has been reached and the path found by the recursive call on the subforest otherwise.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">chop ::</span> <span class="dt">Forest</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">MaybeT</span> <span class="dt">SetM</span> <span class="dt">Path</span>
chop []               <span class="fu">=</span> mzero
chop (<span class="dt">Node</span> v ts <span class="fu">:</span> fs) <span class="fu">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> lift (contains v)
                           <span class="kw">if</span> b <span class="kw">then</span> chop fs
                                  <span class="kw">else</span> <span class="kw">do</span> lift (include v)
                                          fmap (<span class="fu">|&gt;</span> v) candidate <span class="ot">`mplus`</span> chop fs

                          <span class="kw">where</span> candidate <span class="fu">|</span> null ts   <span class="fu">=</span> return empty
                                          <span class="fu">|</span> otherwise <span class="fu">=</span> chop ts</code></pre>
<p>The actual disjoint paths function computes the reachability forest and then prunes every single forest <code class="sourceCode haskell">[<span class="dt">Node</span> i f]</code> where <code class="sourceCode haskell">(i, f)<span class="ot"> ::</span> <span class="dt">Arc</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>)</code> is a vertex-value pair that is contained in the result vector of <code class="sourceCode haskell">reachForest</code>. Finally, the monadic set that is used for the computation is &quot;left&quot; and the resulting list of <code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Path</span></code> values is transformed into a list of paths by <code class="sourceCode haskell">catMaybes</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">disjointPaths ::</span> <span class="dt">Int</span>      <span class="co">-- number of vertices in the graph(s)</span>
              <span class="ot">-&gt;</span> <span class="dt">Vec</span> a    <span class="co">-- start vector</span>
              <span class="ot">-&gt;</span> <span class="dt">Vec</span> b    <span class="co">-- target vector</span>
              <span class="ot">-&gt;</span> [<span class="dt">Mat</span> c]  <span class="co">-- list of traversed graphs in every step</span>
              <span class="ot">-&gt;</span> [<span class="dt">Path</span>]
disjointPaths n start end gs <span class="fu">=</span> catMaybes (process (reachForest start end gs)) <span class="kw">where</span>

    process <span class="fu">=</span> runNew n <span class="fu">.</span> mapM (runMaybeT <span class="fu">.</span> chop <span class="fu">.</span> return <span class="fu">.</span> uncurry <span class="dt">Node</span>) <span class="fu">.</span> unVec</code></pre>
<h2 id="monadic-set-interface">Monadic set interface</h2>
<p>The following monadic set interface is very similar to the one in <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Graph.html"><code>Data.Graph</code></a>. and can be replaced with a pure set representation by <code class="sourceCode haskell"><span class="dt">Data.IntSet</span></code>. All of the definitions below are almost identical to the ones from <code class="sourceCode haskell"><span class="dt">Data.Graph</span></code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">SetM</span> a <span class="fu">=</span> <span class="dt">Set</span> {<span class="ot"> runSet ::</span> forall s <span class="fu">.</span> <span class="dt">STArray</span> s <span class="dt">Int</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s a }

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">SetM</span> <span class="kw">where</span>

    return x <span class="fu">=</span> <span class="dt">Set</span> (const (return x))

    <span class="dt">Set</span> m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Set</span> fun <span class="kw">where</span>
        fun arr <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> m arr
                     runSet (f x) arr

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">SetM</span> <span class="kw">where</span>
    fmap <span class="fu">=</span> liftM

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">SetM</span> <span class="kw">where</span>
    pure  <span class="fu">=</span> return
    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</code></pre>
<p>Checks whether an index is contained in the set or not.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">contains ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SetM</span> <span class="dt">Bool</span>
contains x <span class="fu">=</span> <span class="dt">Set</span> (<span class="ot">`readArray`</span> x)</code></pre>
<p>Inserts the given index in the set.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">include ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SetM</span> ()
include x <span class="fu">=</span> <span class="dt">Set</span> (\arr <span class="ot">-&gt;</span> writeArray arr x <span class="dt">True</span>)</code></pre>
<p>Produces the value associated with the given set. The <code class="sourceCode haskell"><span class="dt">Int</span></code> denotes the size of the set.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runNew ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SetM</span> a <span class="ot">-&gt;</span> a
runNew n set <span class="fu">=</span> runST (newArray (<span class="dv">0</span>, n <span class="fu">-</span> <span class="dv">1</span>) <span class="dt">False</span> <span class="fu">&gt;&gt;=</span> runSet set)</code></pre>
<h1 id="example-matrices-and-vectors">Example Matrices and Vectors</h1>
<h2 id="examples-by-hand">Examples by hand</h2>
<p>This is the matrix <span class="math">\(A\)</span> from Section 3 of the paper:</p>
<p><span class="math">\[ A= \begin{pmatrix}
            0 &amp; 1 &amp; 1\\
           0 &amp; 0 &amp; 1\\
            0 &amp; 2 &amp; 0
     \end{pmatrix}
\]</span></p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">matA ::</span> <span class="dt">Mat</span> <span class="dt">Int</span>
matA <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">$</span> <span class="dt">Vec</span> [(<span class="dv">0</span>, <span class="dt">Vec</span> [(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">1</span>)]),
                  (<span class="dv">1</span>, <span class="dt">Vec</span> [(<span class="dv">2</span>, <span class="dv">1</span>)]),
                  (<span class="dv">2</span>, <span class="dt">Vec</span> [(<span class="dv">1</span>, <span class="dv">2</span>)])]</code></pre>
<p>Two arbitrary matrices.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">mat1 ::</span> <span class="dt">Mat</span> (<span class="dt">Number</span> <span class="dt">Integer</span>)
mat1 <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">$</span> <span class="dt">Vec</span> [(<span class="dv">0</span>, <span class="dt">Vec</span> [(<span class="dv">3</span>,  <span class="dv">2</span>),(<span class="dv">5</span>,  <span class="dv">0</span>)]),
                  (<span class="dv">1</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,  <span class="dv">2</span>),(<span class="dv">3</span>, <span class="dv">1</span>),(<span class="dv">5</span>,  <span class="dv">0</span>)]),
                  (<span class="dv">2</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,  <span class="dv">2</span>),(<span class="dv">1</span>, <span class="fu">-</span><span class="dv">1</span>),(<span class="dv">5</span>,  <span class="dv">0</span>)]),
                  (<span class="dv">3</span>, <span class="dt">Vec</span> [(<span class="dv">5</span>,  <span class="fu">-</span> <span class="dv">2</span>) ] ) ,
                  (<span class="dv">4</span>, <span class="dt">Vec</span> []),
                  (<span class="dv">5</span>, <span class="dt">Vec</span> [(<span class="dv">4</span>, <span class="dv">1</span>)])]

<span class="ot">mat2 ::</span> <span class="dt">Mat</span> <span class="dt">Char</span>
mat2 <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">$</span> <span class="dt">Vec</span> [(<span class="dv">0</span>, <span class="dt">Vec</span> [(<span class="dv">3</span>,<span class="ch">&#39;g&#39;</span>)]),
                  (<span class="dv">1</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,<span class="ch">&#39;z&#39;</span>),(<span class="dv">4</span>,<span class="ch">&#39;p&#39;</span>),(<span class="dv">8</span>,<span class="ch">&#39;n&#39;</span>),(<span class="dv">9</span>,<span class="ch">&#39;v&#39;</span>)]),
                  (<span class="dv">2</span>, <span class="dt">Vec</span> [(<span class="dv">2</span>,<span class="ch">&#39;e&#39;</span>),(<span class="dv">4</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">7</span>,<span class="ch">&#39;e&#39;</span>)]),
                  (<span class="dv">3</span>, <span class="dt">Vec</span> [(<span class="dv">4</span>,<span class="ch">&#39;i&#39;</span>)]),
                  (<span class="dv">4</span>, <span class="dt">Vec</span> [(<span class="dv">4</span>,<span class="ch">&#39;o&#39;</span>)]),
                  (<span class="dv">5</span>, <span class="dt">Vec</span> [(<span class="dv">4</span>,<span class="ch">&#39;v&#39;</span>),(<span class="dv">6</span>,<span class="ch">&#39;x&#39;</span>),(<span class="dv">8</span>,<span class="ch">&#39;d&#39;</span>),(<span class="dv">9</span>,<span class="ch">&#39;r&#39;</span>)]),
                  (<span class="dv">6</span>, <span class="dt">Vec</span> [(<span class="dv">1</span>,<span class="ch">&#39;y&#39;</span>),(<span class="dv">2</span>,<span class="ch">&#39;p&#39;</span>),(<span class="dv">3</span>,<span class="ch">&#39;f&#39;</span>),(<span class="dv">4</span>,<span class="ch">&#39;s&#39;</span>),(<span class="dv">5</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">6</span>,<span class="ch">&#39;j&#39;</span>)]),
                  (<span class="dv">7</span>, <span class="dt">Vec</span> [(<span class="dv">3</span>,<span class="ch">&#39;v&#39;</span>),(<span class="dv">6</span>,<span class="ch">&#39;f&#39;</span>),(<span class="dv">9</span>,<span class="ch">&#39;v&#39;</span>)]),
                  (<span class="dv">8</span>, <span class="dt">Vec</span> [(<span class="dv">2</span>,<span class="ch">&#39;g&#39;</span>),(<span class="dv">4</span>,<span class="ch">&#39;m&#39;</span>),(<span class="dv">5</span>,<span class="ch">&#39;k&#39;</span>),(<span class="dv">7</span>,<span class="ch">&#39;w&#39;</span>),(<span class="dv">8</span>,<span class="ch">&#39;k&#39;</span>)]),
                  (<span class="dv">9</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">2</span>,<span class="ch">&#39;a&#39;</span>)])]</code></pre>
<p>These two matrices are structurally identical, but the first one contains <code class="sourceCode haskell"><span class="dt">Char</span></code> values, while the second one contains only ones of the type <code class="sourceCode haskell"><span class="dt">Number</span> <span class="dt">Int</span></code>. These two correspond to the graphs <span class="math">\(G&#39;\)</span> and <span class="math">\(G\)</span> from Section 1.</p>
<div class="figure">
<img src="./graphLabelled.png" alt="Graph G&#39;" /><p class="caption">Graph <span class="math">\(G&#39;\)</span></p>
</div>
<div class="figure">
<img src="./graph.png" alt="Graph G" /><p class="caption">Graph <span class="math">\(G\)</span></p>
</div>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">graphChar ::</span> <span class="dt">Mat</span> <span class="dt">Char</span>
graphChar <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">$</span> <span class="dt">Vec</span> [(<span class="dv">0</span>, <span class="dt">Vec</span> []),
                       (<span class="dv">1</span>, <span class="dt">Vec</span> [(<span class="dv">2</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">3</span>,<span class="ch">&#39;s&#39;</span>),(<span class="dv">6</span>,<span class="ch">&#39;i&#39;</span>)]),
                       (<span class="dv">2</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,<span class="ch">&#39;m&#39;</span>)]),
                       (<span class="dv">3</span>, <span class="dt">Vec</span> [(<span class="dv">2</span>,<span class="ch">&#39;p&#39;</span>),(<span class="dv">4</span>,<span class="ch">&#39;l&#39;</span>),(<span class="dv">7</span>,<span class="ch">&#39;e&#39;</span>)]),
                       (<span class="dv">4</span>, <span class="dt">Vec</span> []),
                       (<span class="dv">5</span>, <span class="dt">Vec</span> [(<span class="dv">3</span>,<span class="ch">&#39;g&#39;</span>)]),
                       (<span class="dv">6</span>, <span class="dt">Vec</span> [(<span class="dv">0</span>,<span class="ch">&#39;r&#39;</span>),(<span class="dv">6</span>,<span class="ch">&#39;a&#39;</span>)]),
                       (<span class="dv">7</span>, <span class="dt">Vec</span> [(<span class="dv">3</span>,<span class="ch">&#39;p&#39;</span>),(<span class="dv">8</span>, <span class="ch">&#39;h&#39;</span>)]),
                       (<span class="dv">8</span>, <span class="dt">Vec</span> [])]

<span class="ot">graphNumber ::</span> <span class="dt">Mat</span> (<span class="dt">Number</span> <span class="dt">Int</span>)
graphNumber <span class="fu">=</span> fmap (const <span class="dv">1</span>) graphChar</code></pre>
<p>These two vectors are structurally identical, but the first one contains only <code class="sourceCode haskell">()</code> values and the second one contains only ones of the type <code class="sourceCode haskell"><span class="dt">Number</span> <span class="dt">Int</span></code>. Both are variants of the vector <span class="math">\(v_X\)</span> from Section 1.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">vec ::</span> <span class="dt">Vec</span> ()
vec <span class="fu">=</span> toVec [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>]

<span class="ot">vecNumber ::</span> <span class="dt">Vec</span> (<span class="dt">Number</span> <span class="dt">Int</span>)
vecNumber <span class="fu">=</span> fmap (const <span class="dv">1</span>) vec</code></pre>
<h2 id="random-examples">Random examples</h2>
<p>Random matrices can be generated with the following function.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">randomMatrix ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ random generator number</span>
                        <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ number of vertices</span>
                        <span class="ot">-&gt;</span> <span class="dt">Double</span>  <span class="co">-- ^ density between 0 and 1</span>
                        <span class="ot">-&gt;</span> (a, a)  <span class="co">-- ^ lower and upper bounds for the random values</span>
                        <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
randomMatrix <span class="fu">=</span> matlikeToMat randomSquareMatLike</code></pre>
<p>The following function takes a <code class="sourceCode haskell"><span class="dt">MatLike</span> a</code> value and transforms it into an actual matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fromAssociationList ::</span> <span class="dt">MatLike</span> a <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
fromAssociationList <span class="fu">=</span> <span class="dt">Mat</span> <span class="fu">.</span> <span class="dt">Vec</span> <span class="fu">.</span> map (second <span class="dt">Vec</span>)</code></pre>
<p>For instance</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">graphRandom1 ::</span> <span class="dt">Mat</span> <span class="dt">Char</span>
graphRandom1 <span class="fu">=</span> randomMatrix <span class="dv">23571113</span> <span class="dv">10</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">25</span> (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;e&#39;</span>)

<span class="ot">graphRandom2 ::</span> <span class="dt">Mat</span> (<span class="dt">Number</span> <span class="dt">Int</span>)
graphRandom2 <span class="fu">=</span> randomMatrix <span class="dv">12345</span> <span class="dv">5</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span> (<span class="dv">0</span>, <span class="dv">20</span>)</code></pre>
<p>The following function takes a random construction and produces a matrix. It is used to &quot;redefine&quot; all generators to yield actual matrices.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">matlikeToMat ::</span> (<span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">MatLike</span> a)
             <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
matlikeToMat generator rng size dens bnds <span class="fu">=</span>
    fromAssociationList (generator (mkStdGen rng) size dens bnds)</code></pre>
<p>Creates diagonal matrices. The density refers to the density along the diagonal, <em>not</em> to the complete matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">randomDiagonalMatrix <span class="ot">::</span>
    <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ random generator</span>
             <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ number of rows and columns</span>
             <span class="ot">-&gt;</span> <span class="dt">Double</span>  <span class="co">-- ^ density (/0 &lt;= d &lt;= 1/)</span>
             <span class="ot">-&gt;</span> (a, a)  <span class="co">-- ^ lower\/upper bounds</span>
             <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
randomDiagonalMatrix <span class="fu">=</span> matlikeToMat randomDiagonalLike</code></pre>
<p>Creates lower triangle matrices. The density refers to the density in the lower triangle block (including the diagonal) only, <em>not</em> to the complete matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">randomTriangleMatrix <span class="ot">::</span>
    <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ random generator</span>
             <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ number of rows and columns</span>
             <span class="ot">-&gt;</span> <span class="dt">Double</span>  <span class="co">-- ^ density (/0 &lt;= d &lt;= 1/)</span>
             <span class="ot">-&gt;</span> (a, a)  <span class="co">-- ^ lower\/upper bounds</span>
             <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
randomTriangleMatrix <span class="fu">=</span> matlikeToMat randomTriangleLike</code></pre>
<p>Creates strict lower triangle matrices, i.e. the diagonal is empty. The density refers to the density in the strictly lower triangle block only, <em>not</em> to the complete matrix.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">randomStrictTriangleMatrix <span class="ot">::</span>
    <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ random generator</span>
             <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ number of rows and columns</span>
             <span class="ot">-&gt;</span> <span class="dt">Double</span>  <span class="co">-- ^ density (/0 &lt;= d &lt;= 1/)</span>
             <span class="ot">-&gt;</span> (a, a)  <span class="co">-- ^ lower\/upper bounds</span>
             <span class="ot">-&gt;</span> <span class="dt">Mat</span> a
randomStrictTriangleMatrix <span class="fu">=</span> matlikeToMat randomStrictTriangleLike</code></pre>
<p>This function creates a random vector. Internally it creates a <span class="math">\(1 \times n\)</span> matrix, where <span class="math">\(n\)</span> is the supplied size value and transforms it into a vector.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">randomVector <span class="ot">::</span>
    <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>    <span class="co">-- ^ random generator</span>
             <span class="ot">-&gt;</span> <span class="dt">Int</span>    <span class="co">-- ^ number of columns</span>
             <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ density (/0 &lt;= d &lt;= 1/)</span>
             <span class="ot">-&gt;</span> (a, a) <span class="co">-- ^ lower\/upper bounds</span>
             <span class="ot">-&gt;</span> <span class="dt">Vec</span> a
randomVector rng size dens bnds <span class="fu">=</span>
    <span class="dt">Vec</span> (snd (head (randomMatLike (mkStdGen rng) <span class="dv">1</span> size dens bnds)))</code></pre>
</body>
</html>
